{"componentChunkName":"component---src-pages-blog-markdown-remark-frontmatter-slug-tsx","path":"/blog/web/csr-ssr-ssg/","result":{"data":{"markdownRemark":{"html":"<h2>CSR (Client Side Rendering)</h2>\n<p>CSR은 클라이언트 측에서 Javascript를 사용하여 <strong>동적으로 페이지를 렌더링</strong> 하는 방식.</p>\n<p>즉, 클라이언트에서 데이터 요청 시 서버에서는 필요한 데이터만 전달하고, 클라이언트에서 데이터와 javascript를 이용하여 페이지를 렌더링 한다.</p>\n<p>대표적으로 SPA(react, Angular ,Vue)가 여기에 속한다.</p>\n<h3>1. 동작 방식</h3>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f2e487ff7742275326d3aa776706e0f8/71d2f/csr.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACHUlEQVR42o1Ty44SQRTtj2ExG//DHTsJS//CNSZjMnHjDxDCwlkQMsHEuDCDwY1GWCDgAM370byHpunm/TjmXKgeA2i8SXV136576zyqtHq9jng8jkQigVKpBIZt25jP55hOp+D/Vqsludls5o7hcIj9fo/T0AqFAizLwmKxQC6Xw3a7RbfblYLBYIB2uw3DMNDv9+VbjXK5LGvPGtZqNYRCIQSDQVQqFSnkYs6dTkeK+c5Ner2eDObH4zEuhcZHLBZDJBKRxGazwXK5FFq6rgtC0zRFAsdxsF6vZaxWK6GsaKtZY1EqlUI6nUY2m5XkbreTBWymGlJDhZDaqmB+NBpJjashKZBWJpNxd6M+1G4ymUiO30RJZGTBoO5+vx8ej0eMlYYsurl5g+vr12g0GkKHc7PZFIer1apoyndlEF3P5/NinNfrxdXVFaLR6JOGv7Il/EwXXLpEoxwkchrHk0DkRMd/Ss9AIACfzyeSScN6vYxvyTC+J2+h6w9HyrsT7yj47qKryiDX5WI6iS/3b1H7/AylH7foDW0U8g9CjbQP9FswjDEMoyO0mecxYhApdX5yOZPFuxcvEX71HMXM18Ouxx1J33FmsO1HWONPcBwT6/VWEF+6Ja6Gdx8/4H3kDrs9ThbvYVk2TLOHx0EYptnFYrE6a/Jnc82eTqEXi6iUdUwm5tkColRn7H9CU1eLmv3tOh022R5vxr8b/gZc+BaZqb5lGAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"csr 동작 순서\"\n        title=\"\"\n        src=\"/static/f2e487ff7742275326d3aa776706e0f8/00d43/csr.png\"\n        srcset=\"/static/f2e487ff7742275326d3aa776706e0f8/63868/csr.png 250w,\n/static/f2e487ff7742275326d3aa776706e0f8/0b533/csr.png 500w,\n/static/f2e487ff7742275326d3aa776706e0f8/00d43/csr.png 1000w,\n/static/f2e487ff7742275326d3aa776706e0f8/71d2f/csr.png 1485w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">csr 동작 순서</figcaption>\n  </figure></p>\n<ol>\n<li>브라우저에서 웹사이트 접속하여 웹 페이지 요청하기</li>\n<li>클라이언트에서 요청한 웹 페이지 전달하기(앱에서 필요한 js 링크가 포함된 단순한 html페이지 전달)</li>\n<li>서버에 앱에서 필요한 javascript파일을 요청 후 다운로드 받음 (모든 소스 코드가 포함되어 있기 때문에 크기가 크고 다운 받는 데 시간이 걸릴 수 있음)</li>\n</ol>\n<h3>2. 장점</h3>\n<ul>\n<li>초기 로딩이 끝나고 이후 작업에서는 서버에 의존하지 않고 클라이언트 자체내에서 빠른 페이지 화면 전환</li>\n<li>페이지의 일부분만 동적으로 업데이트 할 수 있기 때문에, 전체 페이지를 다시 로드하지 않고도 빠른 인터랙션 가능</li>\n</ul>\n<h3>3. 단점</h3>\n<ul>\n<li>사용자가 첫 화면을 보게 될 경우 javascript파일을 다운받아야 하므로, 느린 로딩이 발생하고 시간도 오래 걸릴 수 있다.</li>\n<li>초기 페이지 로딩시 html은 아무 내용이 없기때문에, 검색 엔진이 크롤링 할 수 있는 내용이 적어져 SEO문제가 발생한다.</li>\n</ul>\n<h2>SSR(Server Side Rendering)</h2>\n<p>서버에서 HTML과 필요한 데이터를 렌더링하고, 클라이언트에 전달하여 브라우저에서 페이지를 보여 주는 방식</p>\n<h3>1. 동작 방식</h3>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/488fa5fbd795f7d9ce9da662315be585/71d2f/ssr.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.60000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACGklEQVR42qVTTWsaURT1X/hD3HVXcFEodNM/4KZ07T8oXZRsumopWCQgpRRioCQBaSoZYkChiMYGdabjfOj4Ua06Hb9Qx5k55V7jVNumofTCnTfvvvfOu/ec+wL1eh2CICCTyaBWq4FsuVxitVphsVig1+thMBjwv23bvtOeP1lAkiSMRiPM53NUKhVMp1NUq1WoqspOMZrrug5N06AoCns+n+dLfwOkTfv7ccTjr3ljv9/ng8PhELIsM5goiiiXy6BqaL3b7fJI5rouHMeB53lrQPqcps5wcnx6fYfnL1K2lmVhPB6z31TmToaKUkH28jny+SeoXGX9W7ft1/nmQhpjsRii0ShXx4ByqYiLowSMj3ch5RIctL6bnNFkMmFBSqUSC7bJlDgnsUzTRDgcRjAYRDKZXAMaioqn9x9i79E9aPIlHBf42unwgY0TZ52tGM0bjQYDRyIRhEIhpNPpnxxeXH1CKne+qQf/YoVCAalUiqthwHqtgbNXWQgvipDLGgcdx70VaMMjCUU96qssFz8j9/Yc+ofHqBWP0P1mQRJFtNttNJtNGEYdui5xC1EvtlotGIbBZRMIOYnmAypfSnj38gGSh3cgSgIHbXsJz1tnuZwr6DSfQVUNmObQV93bomb7nzk8ODjGm8T7a/q8HRpdl56ZicWCnqN9ex/OZjMMBn1Y1hDT6QT/awGSnp4ROfXVDRLslPU3wB/VmxUZC/zhPwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ssr 동작 순서\"\n        title=\"\"\n        src=\"/static/488fa5fbd795f7d9ce9da662315be585/00d43/ssr.png\"\n        srcset=\"/static/488fa5fbd795f7d9ce9da662315be585/63868/ssr.png 250w,\n/static/488fa5fbd795f7d9ce9da662315be585/0b533/ssr.png 500w,\n/static/488fa5fbd795f7d9ce9da662315be585/00d43/ssr.png 1000w,\n/static/488fa5fbd795f7d9ce9da662315be585/71d2f/ssr.png 1485w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">ssr 동작 순서</figcaption>\n  </figure></p>\n<ol>\n<li>브라우저에서 웹사이트 접속하여 웹 페이지 요청하기</li>\n<li>서버에서 렌더링에 필요한 파일(HTML + CSS + JS)파일을 만들어 브라우저에게 보냄</li>\n<li>브라우저에서는 로딩 없이 페이지가 표시되지만, 이벤트 같은 동적으로 조작은 불가능</li>\n<li>서버에서 동적 제어 가능한 javascript를 다운받으면 이벤트 동작할 수 있는 인터랙션이 가능</li>\n</ol>\n<h3>2. 장점</h3>\n<ul>\n<li>서버에서 필요한 데이터를 모두 가져와서 브라우저에게 보내기 때문에 초기 페이지 로딩속도가 빠르다.</li>\n<li>html에 모든 컨텐츠가 담겨져 있어서 SEO를 효율적으로 적용할 수 있다.</li>\n</ul>\n<h3>3. 단점</h3>\n<ul>\n<li>웹사이트에 사용자가 많아지면 서버에서 HTML을 생성하여 클라이언트에 전달해야 하는 빈도가 많아지므로 서버의 과부하가 걸리기 쉽다.</li>\n<li>초기 로딩 후 이벤트 동작을 하려면 동적으로 처리하는 javascript를 서버에서 다시 다운 받아야 하는데, 받지 않아서 반응이 없는 경우가 발생할 수 있다.</li>\n</ul>\n<h2>reference</h2>\n<ul>\n<li>\n<p><a href=\"https://tech.weperson.com/wedev/frontend/csr-ssr-spa-mpa-pwa/#csr-client-side-rendering-vs-ssr-server-side-rendering\">CSR/SSR, SPA/MPA, PWA</a></p>\n</li>\n<li>\n<p><a href=\"https://www.youtube.com/watch?v=iZ9csAfU5Os&#x26;t=196s\">서버사이드 렌더링 (개발자라면 상식으로 알고 있어야 하는 개념 정리 ⭐️)</a></p>\n</li>\n</ul>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","frontmatter":{"date":"2023.04.19","slug":"/web/csr-ssr-ssg","title":"Web 렌더링 종류와 방식","desc":" 렌더링 따라 동작 원리 이해","categories":["Web"],"topbg":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#08a8d8","images":{"fallback":{"src":"/static/db526bf571ac65450b5ef7510a615090/a11ea/topbg.png","srcSet":"/static/db526bf571ac65450b5ef7510a615090/60f85/topbg.png 799w,\n/static/db526bf571ac65450b5ef7510a615090/1be0d/topbg.png 1598w,\n/static/db526bf571ac65450b5ef7510a615090/a11ea/topbg.png 3196w","sizes":"(min-width: 3196px) 3196px, 100vw"},"sources":[{"srcSet":"/static/db526bf571ac65450b5ef7510a615090/89634/topbg.webp 799w,\n/static/db526bf571ac65450b5ef7510a615090/10e89/topbg.webp 1598w,\n/static/db526bf571ac65450b5ef7510a615090/4bd66/topbg.webp 3196w","type":"image/webp","sizes":"(min-width: 3196px) 3196px, 100vw"}]},"width":3196,"height":427}}}}}},"pageContext":{"id":"6185409b-65a5-532b-90c4-b752d1d45550","frontmatter__slug":"/web/csr-ssr-ssg","__params":{"frontmatter__slug":"web"}}},"staticQueryHashes":["3941441684"],"slicesMap":{}}